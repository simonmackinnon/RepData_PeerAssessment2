Reproducible Research: Peer Assessment 2
==========================================
Created by Simon Mackinnon on January 13, 2015
[Reproducable Research - Coursera](https://www.coursera.org/course/repdata)

## Economic and Public Health Effects of Storms and Other Severe Weather Events 

### Synopsis


### Settings
```{r settings}
options(scipen = 999) 
library(R.utils)
library(dplyr)
library(ggplot2)
```

### Data Processing
The data to be used for this analysis is available for download via the course website at [Storm Data](https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2FStormData.csv.bz2).    

If the .csv file isn't already extracted, and the zip file doesn't exist, then we should download and then extract it.
```{r downloadingAndExtracting, echo=TRUE}
zip_filename <- "./data/repdata-data-StormData.csv.bz2"
data_filename <- "./data/repdata-data-StormData.csv"

if (!file.exists("./data"))
{
  dir.create("./data")
}

if (!file.exists(data_filename))
{
  if (!file.exists(zip_filename))
  {
    url <- "http://d396qusza40orc.cloudfront.net/repdata%2Fdata%2FStormData.csv.bz2"
    #record the time/location of the downloaded file
    print (paste("Downloading file from:", url ,"at:", format(Sys.Date(), "%B %d, %Y"), format(Sys.time(), "%H:%M:%S")))
    #changed url to be http, as download file has issues with https
    
    download.file(url, 
                  destfile = zip_filename,
                  mode="wb")
  }
  
  bunzip2(zip_filename, overwrite=T, remove=F)
}
```



Once we have the .csv file, we need to read it into R.

```{r dataReading, echo=TRUE}
# this may take some time!
stormData <- read.csv(data_filename, 
                      header=TRUE, 
                      sep=",",
                      stringsAsFactors=FALSE)

rm(data_filename, zip_filename)

#confirm the number dimensions of the read data
dim(stormData)


#and display the head rows
head(stormData)

```
There are **`r nrow(stormData)` rows** and **`r ncol(stormData)` columns** in the read data.


### Data Selection and Filtering

Looking at the details of how the data was collected at the [Storm Events Database](http://www.ncdc.noaa.gov/stormevents/details.jsp), we can see that only observations from 1996 onwards includes data from *All Event Types (48 from Directive 10-1605)*, (as defined in [NWS Directive 10-1605](http://www.ncdc.noaa.gov/stormevents/pd01016005curr.pdf)).  

We can verify that most of the observations were recorded after this date as well, by observing the frequency of observations per year in the **stormData$BGN_DATE** variable

```{r observationFrequencyPerYear, echo=TRUE, fig.align='center', fig.width=7, fig.height=5}

year <- year(as.Date(stormData$BGN_DATE, format = "%m/%d/%Y"))

#break up the year data into 3 types
yearType <- sapply(as.numeric(year), function(x) 
    if (x >= 1950 & x <= 1955){1} 
    else if (x <= 1996) {2} 
    else if (x <= 2011) {3}
    else {0})

#bind into a marix, then coerce to a data frame
yearData <- data.frame(cbind(year, yearType))

#create the histogram
ggplot(yearData, aes(x=year)) + 
geom_histogram(binwidth = 1, aes(fill = factor(yearData$yearType))) +
scale_fill_discrete(name="Year Type", 
                    labels= c("1. Tornado\n1950-1955\n",
                              "2. Tornado,\nThunderstorm Wind\nand Hail\n1956-1995\n",
                              "3. All Event\nTypes (48 from\nDirective 10-1605)\n1996-2011")) +
labs(title = "Histogram of Number of\nObservarions Recorded Per Year (1950 - 2011)",
     x = "Year",
     y = "Number of Observations Recorded")


```

Based on this, we filter the data to only use observations from 1996 onwards.

```{r dataFiltering, echo=TRUE}

#append the year values for filtering
stormData$year <- year
#subset the data for all values of year greater or equal to 1996
stormData <- stormData[stormData$year >= 1996,]
#display the dimensions of the filtered data
dim(stormData)

rm(year, yearType, yearData)

```
After filtering, there are **`r nrow(stormData)` rows** and **`r ncol(stormData)` columns** in the filtered data.

### Results

#### Economic Effects

For the economic effects of sever weather, we must isolate what parts of the data define this.

Using the code book, ([Storm Events](http://ire.org/nicar/database-library/databases/storm-events/)), we can see that the columns PROPDMG and CROPDMG indicate the value of damage to property and crops respectively. Each of those columns is followed by a corresponding *EXP column, which indicates an exponent (H-Hundreds, K-Thousands, M-Millions, B-Billions). 

In order to aggregate the property and crop damage costs per event type, a common unit will need to be used (in this case, whole dollars.) In order to do this, two additional columns PROPDMGTOTAL and CROPDMGTOTAL will be introduced, which will be the *DMG value multiplied by the appropriate *DMGEXP value.

```{r EconomicEffects, echo=TRUE}

#subset data for crop damage cost, property damage cost (with exponents) and ev-type

stormDataEcon <- stormData[,c("EVTYPE", 
                              "PROPDMG", 
                              "PROPDMGEXP", 
                              "CROPDMG", 
                              "CROPDMGEXP")]

stormDataEcon$PROPDMGTOTAL <- stormDataEcon$PROPDMG
stormDataEcon$CROPDMGTOTAL <- stormDataEcon$CROPDMG

stormDataEcon <- stormDataEcon[stormDataEcon$PROPDMG != 0 | stormDataEcon$CROPDMG != 0,]

for (i in 1:nrow(stormDataEcon))
{
    if (stormDataEcon$PROPDMG[i] != 0)
    {
        if (stormDataEcon$PROPDMGEXP[i] == "H")
            stormDataEcon$PROPDMGTOTAL[i] <- stormDataEcon$PROPDMG[i] * 100
        else if (stormDataEcon$PROPDMGEXP[i] == "K")
            stormDataEcon$PROPDMGTOTAL[i] <- stormDataEcon$PROPDMG[i] * 1000
        else if (stormData$PROPDMGEXP[i] == "M")
            stormDataEcon$PROPDMGTOTAL[i] <- stormDataEcon$PROPDMG[i] * 1000000
        else if (stormDataEcon$PROPDMGEXP[i] == "B")
            stormDataEcon$PROPDMGTOTAL[i] <- stormDataEcon$PROPDMG[i] * 1000000000    
    }
    
    if (stormDataEcon$CROPDMG[i] != 0)
    {
        if (stormDataEcon$CROPDMGEXP[i] == "H")
            stormDataEcon$CROPDMGTOTAL[i] <- stormDataEcon$CROPDMG[i] * 100
        else if (stormDataEcon$CROPDMGEXP[i] == "K")
            stormDataEcon$CROPDMGTOTAL[i] <- stormDataEcon$CROPDMG[i] * 1000
        else if (stormData$CROPDMGEXP[i] == "M")
            stormDataEcon$CROPDMGTOTAL[i] <- stormDataEcon$CROPDMG[i] * 1000000
        else if (stormDataEcon$CROPDMGEXP[i] == "B")
            stormDataEcon$CROPDMGTOTAL[i] <- stormDataEcon$CROPDMG[i] * 1000000000
    }
}

# 
# 
# #cost summation aggregrate by ev-type
# economicImpactEventTypeAggregate <- aggregate(stormDataEcon,
#                                               by = list(stormDataEcon$EVTYPE),
#                                               FUN = function(x){sum(as.numeric(x))})

#plot 

```


#### Public Health Effects
```{r Public Health Effects, echo=TRUE}
#subset data for injuries, fatalities and ev-type
#summation aggregrate by ev-type
#plot 

```



